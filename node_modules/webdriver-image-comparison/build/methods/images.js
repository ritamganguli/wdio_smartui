"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addBlockOuts = exports.saveBase64Image = exports.makeFullPageBase64Image = exports.executeImageCompare = exports.makeCroppedBase64Image = exports.checkBaselineImageExists = void 0;
var fs_extra_1 = require("fs-extra");
var path_1 = require("path");
var canvas_1 = require("canvas");
var compareImages_1 = require("../resemble/compareImages");
var utils_1 = require("../helpers/utils");
var constants_1 = require("../helpers/constants");
var rectangles_1 = require("./rectangles");
var options_interface_1 = require("../helpers/options.interface");
function checkBaselineImageExists(actualFilePath, baselineFilePath, autoSaveBaseline, logLevel) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2, new Promise(function (resolve, reject) {
                    (0, fs_extra_1.access)(baselineFilePath, function (error) {
                        if (error) {
                            if (autoSaveBaseline) {
                                try {
                                    (0, fs_extra_1.copySync)(actualFilePath, baselineFilePath);
                                    if (logLevel === options_interface_1.LogLevel.info) {
                                        console.log('\x1b[33m%s\x1b[0m', "\n#####################################################################################\n INFO:\n Autosaved the image to\n ".concat(baselineFilePath, "\n#####################################################################################\n"));
                                    }
                                }
                                catch (error) {
                                    reject("\n#####################################################################################\n Image could not be copied. The following error was thrown:\n ".concat(error, "\n#####################################################################################\n"));
                                }
                            }
                            else {
                                reject("\n#####################################################################################\n Baseline image not found, save the actual image manually to the baseline.\n The image can be found here:\n ".concat(actualFilePath, "\n If you want the module to auto save a non existing image to the baseline you\n can provide 'autoSaveBaseline: true' to the options.\n#####################################################################################\n"));
                            }
                        }
                        resolve();
                    });
                })];
        });
    });
}
exports.checkBaselineImageExists = checkBaselineImageExists;
function makeCroppedBase64Image(_a) {
    var addIOSBezelCorners = _a.addIOSBezelCorners, base64Image = _a.base64Image, deviceName = _a.deviceName, devicePixelRatio = _a.devicePixelRatio, isIos = _a.isIos, isLandscape = _a.isLandscape, logLevel = _a.logLevel, rectangles = _a.rectangles, _b = _a.resizeDimensions, resizeDimensions = _b === void 0 ? constants_1.DEFAULT_RESIZE_DIMENSIONS : _b;
    return __awaiter(this, void 0, void 0, function () {
        var _c, screenshotHeight, screenshotWidth, isRotated, newBase64Image, _d, resizeValues, _e, top, right, bottom, left, height, width, x, y, canvasWidth, canvasHeight, canvas, image, ctx, sourceXStart, sourceYStart, normalizedDeviceName, isSupported, isIosBezelError, _f, topImageName, bottomImageName, topImage, bottomImage, topBase64Image, _g, bottomBase64Image, _h, _j, _k, _l, _m;
        return __generator(this, function (_o) {
            switch (_o.label) {
                case 0:
                    _c = (0, utils_1.getScreenshotSize)(base64Image, devicePixelRatio), screenshotHeight = _c.height, screenshotWidth = _c.width;
                    isRotated = isLandscape && screenshotHeight > screenshotWidth;
                    if (!isRotated) return [3, 2];
                    return [4, rotateBase64Image({ base64Image: base64Image, degrees: -90, newHeight: screenshotWidth, newWidth: screenshotHeight })];
                case 1:
                    _d = _o.sent();
                    return [3, 3];
                case 2:
                    _d = base64Image;
                    _o.label = 3;
                case 3:
                    newBase64Image = _d;
                    if (typeof resizeDimensions === 'number') {
                        resizeValues = {
                            top: resizeDimensions,
                            right: resizeDimensions,
                            bottom: resizeDimensions,
                            left: resizeDimensions,
                        };
                        if (logLevel === options_interface_1.LogLevel.debug || logLevel === options_interface_1.LogLevel.warn) {
                            console.log('\x1b[33m%s\x1b[0m', "\n#####################################################################################\n WARNING:\n THE 'resizeDimensions' NEEDS TO BE AN OBJECT LIKE\n {\n    top: 10,\n    right: 20,\n    bottom: 15,\n    left: 25,\n }\n NOW IT WILL BE DEFAULTED TO\n  {\n    top: ".concat(resizeDimensions, ",\n    right: ").concat(resizeDimensions, ",\n    bottom: ").concat(resizeDimensions, ",\n    left: ").concat(resizeDimensions, ",\n }\n THIS IS DEPRECATED AND WILL BE REMOVED IN A NEW MAJOR RELEASE\n#####################################################################################\n"));
                        }
                    }
                    else {
                        resizeValues = resizeDimensions;
                    }
                    _e = __assign(__assign({}, constants_1.DEFAULT_RESIZE_DIMENSIONS), resizeValues), top = _e.top, right = _e.right, bottom = _e.bottom, left = _e.left;
                    height = rectangles.height, width = rectangles.width, x = rectangles.x, y = rectangles.y;
                    canvasWidth = width + left + right;
                    canvasHeight = height + top + bottom;
                    canvas = (0, canvas_1.createCanvas)(canvasWidth, canvasHeight);
                    return [4, (0, canvas_1.loadImage)("data:image/png;base64,".concat(newBase64Image))];
                case 4:
                    image = _o.sent();
                    ctx = canvas.getContext('2d');
                    sourceXStart = x - left;
                    sourceYStart = y - top;
                    if (sourceXStart < 0) {
                        if (logLevel === options_interface_1.LogLevel.debug || logLevel === options_interface_1.LogLevel.warn) {
                            console.log('\x1b[33m%s\x1b[0m', "\n#####################################################################################\n THE RESIZE DIMENSION LEFT '".concat(left, "' MADE THE CROPPING GO OUT OF\n THE IMAGE BOUNDARIES RESULTING IN AN IMAGE STARTPOSITION '").concat(sourceXStart, "'.\n THIS HAS BEEN DEFAULTED TO '0'\n#####################################################################################\n"));
                        }
                        sourceXStart = 0;
                    }
                    if (sourceYStart < 0) {
                        if (logLevel === options_interface_1.LogLevel.debug || logLevel === options_interface_1.LogLevel.warn) {
                            console.log('\x1b[33m%s\x1b[0m', "\n#####################################################################################\n THE RESIZE DIMENSION LEFT '".concat(top, "' MADE THE CROPPING GO OUT OF\n THE IMAGE BOUNDARIES RESULTING IN AN IMAGE STARTPOSITION '").concat(sourceYStart, "'.\n THIS HAS BEEN DEFAULTED TO '0'\n#####################################################################################\n"));
                        }
                        sourceYStart = 0;
                    }
                    ctx.drawImage(image, sourceXStart, sourceYStart, canvasWidth, canvasHeight, 0, 0, canvasWidth, canvasHeight);
                    normalizedDeviceName = deviceName
                        .toLowerCase()
                        .replace(/([^A-Za-z0-9]|simulator|inch|(\d(st|nd|rd|th)) generation)/gi, '');
                    isSupported = (normalizedDeviceName.includes('iphone') && constants_1.supportedIosBezelDevices.includes(normalizedDeviceName)) ||
                        (normalizedDeviceName.includes('ipad') &&
                            constants_1.supportedIosBezelDevices.includes(normalizedDeviceName) &&
                            (canvasHeight / devicePixelRatio >= 1133 || canvasWidth / devicePixelRatio >= 1133));
                    isIosBezelError = false;
                    if (!(addIOSBezelCorners && isIos && isSupported)) return [3, 14];
                    _f = (0, utils_1.getIosBezelImageNames)(normalizedDeviceName), topImageName = _f.topImageName, bottomImageName = _f.bottomImageName;
                    if (!(topImageName && bottomImageName)) return [3, 13];
                    topImage = (0, fs_extra_1.readFileSync)((0, path_1.join)(__dirname, "../assets/ios/".concat(topImageName, ".png"))).toString('base64');
                    bottomImage = (0, fs_extra_1.readFileSync)((0, path_1.join)(__dirname, "../assets/ios/".concat(bottomImageName, ".png"))).toString('base64');
                    if (!isLandscape) return [3, 6];
                    return [4, rotateBase64Image({
                            base64Image: topImage,
                            degrees: -90,
                            newHeight: (0, utils_1.getScreenshotSize)(topImage).width,
                            newWidth: (0, utils_1.getScreenshotSize)(topImage).height,
                        })];
                case 5:
                    _g = _o.sent();
                    return [3, 7];
                case 6:
                    _g = topImage;
                    _o.label = 7;
                case 7:
                    topBase64Image = _g;
                    if (!isLandscape) return [3, 9];
                    return [4, rotateBase64Image({
                            base64Image: bottomImage,
                            degrees: -90,
                            newHeight: (0, utils_1.getScreenshotSize)(topImage).width,
                            newWidth: (0, utils_1.getScreenshotSize)(topImage).height,
                        })];
                case 8:
                    _h = _o.sent();
                    return [3, 10];
                case 9:
                    _h = bottomImage;
                    _o.label = 10;
                case 10:
                    bottomBase64Image = _h;
                    _k = (_j = ctx).drawImage;
                    return [4, (0, canvas_1.loadImage)("data:image/png;base64,".concat(topBase64Image))];
                case 11:
                    _k.apply(_j, [_o.sent(), 0, 0]);
                    _m = (_l = ctx).drawImage;
                    return [4, (0, canvas_1.loadImage)("data:image/png;base64,".concat(bottomBase64Image))];
                case 12:
                    _m.apply(_l, [_o.sent(), isLandscape ? canvasWidth - (0, utils_1.getScreenshotSize)(bottomImage).height : 0,
                        isLandscape ? 0 : canvasHeight - (0, utils_1.getScreenshotSize)(bottomImage).height]);
                    return [3, 14];
                case 13:
                    isIosBezelError = true;
                    _o.label = 14;
                case 14:
                    if (addIOSBezelCorners && isIos && !isSupported) {
                        isIosBezelError = true;
                    }
                    if (isIosBezelError) {
                        console.log('\x1b[33m%s\x1b[0m', "\n#####################################################################################\n WARNING:\n We could not find the bezel corners for the device '".concat(deviceName, "'.\n The normalized device name is '").concat(normalizedDeviceName, "'\n and couldn't be found in the supported devices:\n ").concat(constants_1.supportedIosBezelDevices.join(', '), "\n#####################################################################################\n"));
                    }
                    return [2, canvas.toDataURL().replace(/^data:image\/png;base64,/, '')];
            }
        });
    });
}
exports.makeCroppedBase64Image = makeCroppedBase64Image;
function executeImageCompare(executor, options, isViewPortScreenshot) {
    if (isViewPortScreenshot === void 0) { isViewPortScreenshot = false; }
    return __awaiter(this, void 0, void 0, function () {
        var devicePixelRatio, fileName, isAndroidNativeWebScreenshot, isHybridApp, isLandscape, logLevel, platformName, _a, actualFolder, autoSaveBaseline, baselineFolder, browserName, deviceName, diffFolder, isMobile, savePerInstance, diffFilePath, imageCompareOptions, createFolderOptions, actualFolderPath, baselineFolderPath, actualFilePath, baselineFilePath, resembleIgnoreDefaults, ignore, blockOut, statusAddressToolBarOptions, ignoredBoxes, _b, _c, compareOptions, data, rawMisMatchPercentage, reportMisMatchPercentage, isDifference, isDifferenceMessage, debugMessage, diffFolderPath, _d;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    devicePixelRatio = options.devicePixelRatio, fileName = options.fileName, isAndroidNativeWebScreenshot = options.isAndroidNativeWebScreenshot, isHybridApp = options.isHybridApp, isLandscape = options.isLandscape, logLevel = options.logLevel, platformName = options.platformName;
                    _a = options.folderOptions, actualFolder = _a.actualFolder, autoSaveBaseline = _a.autoSaveBaseline, baselineFolder = _a.baselineFolder, browserName = _a.browserName, deviceName = _a.deviceName, diffFolder = _a.diffFolder, isMobile = _a.isMobile, savePerInstance = _a.savePerInstance;
                    imageCompareOptions = __assign(__assign({}, options.compareOptions.wic), options.compareOptions.method);
                    createFolderOptions = { browserName: browserName, deviceName: deviceName, isMobile: isMobile, savePerInstance: savePerInstance };
                    actualFolderPath = (0, utils_1.getAndCreatePath)(actualFolder, createFolderOptions);
                    baselineFolderPath = (0, utils_1.getAndCreatePath)(baselineFolder, createFolderOptions);
                    actualFilePath = (0, path_1.join)(actualFolderPath, fileName);
                    baselineFilePath = (0, path_1.join)(baselineFolderPath, fileName);
                    return [4, checkBaselineImageExists(actualFilePath, baselineFilePath, autoSaveBaseline, logLevel)];
                case 1:
                    _e.sent();
                    resembleIgnoreDefaults = ['alpha', 'antialiasing', 'colors', 'less', 'nothing'];
                    ignore = resembleIgnoreDefaults.filter(function (option) {
                        return Object.keys(imageCompareOptions).find(function (key) {
                            return key.toLowerCase().includes(option) && imageCompareOptions[key];
                        });
                    });
                    blockOut = 'blockOut' in imageCompareOptions ? imageCompareOptions.blockOut : [];
                    statusAddressToolBarOptions = {
                        blockOutSideBar: imageCompareOptions.blockOutSideBar,
                        blockOutStatusBar: imageCompareOptions.blockOutStatusBar,
                        blockOutToolBar: imageCompareOptions.blockOutToolBar,
                        isHybridApp: isHybridApp,
                        isLandscape: isLandscape,
                        isMobile: isMobile,
                        isViewPortScreenshot: isViewPortScreenshot,
                        isAndroidNativeWebScreenshot: isAndroidNativeWebScreenshot,
                        platformName: platformName,
                    };
                    _c = (_b = blockOut)
                        .concat;
                    return [4, (0, rectangles_1.determineStatusAddressToolBarRectangles)(executor, statusAddressToolBarOptions)];
                case 2:
                    ignoredBoxes = _c.apply(_b, [_e.sent()])
                        .map(function (rectangles) {
                        return (0, utils_1.calculateDprData)({
                            bottom: rectangles.y + rectangles.height,
                            right: rectangles.x + rectangles.width,
                            left: rectangles.x,
                            top: rectangles.y,
                        }, devicePixelRatio);
                    });
                    compareOptions = __assign(__assign({ ignore: ignore }, (ignoredBoxes.length > 0 ? { output: { ignoredBoxes: ignoredBoxes } } : {})), { scaleToSameSize: imageCompareOptions.scaleImagesToSameSize });
                    return [4, (0, compareImages_1.default)((0, fs_extra_1.readFileSync)(baselineFilePath), (0, fs_extra_1.readFileSync)(actualFilePath), compareOptions)];
                case 3:
                    data = _e.sent();
                    rawMisMatchPercentage = data.rawMisMatchPercentage;
                    reportMisMatchPercentage = imageCompareOptions.rawMisMatchPercentage
                        ? rawMisMatchPercentage
                        : Number(data.rawMisMatchPercentage.toFixed(3));
                    if (!(rawMisMatchPercentage > imageCompareOptions.saveAboveTolerance || logLevel === options_interface_1.LogLevel.debug)) return [3, 6];
                    isDifference = rawMisMatchPercentage > imageCompareOptions.saveAboveTolerance;
                    isDifferenceMessage = 'WARNING:\n There was a difference. Saved the difference to';
                    debugMessage = 'INFO:\n Debug mode is enabled. Saved the debug file to:';
                    diffFolderPath = (0, utils_1.getAndCreatePath)(diffFolder, createFolderOptions);
                    diffFilePath = (0, path_1.join)(diffFolderPath, fileName);
                    _d = saveBase64Image;
                    return [4, addBlockOuts(Buffer.from(data.getBuffer()).toString('base64'), ignoredBoxes)];
                case 4: return [4, _d.apply(void 0, [_e.sent(), diffFilePath])];
                case 5:
                    _e.sent();
                    if (logLevel === options_interface_1.LogLevel.debug || logLevel === options_interface_1.LogLevel.warn) {
                        console.log('\x1b[33m%s\x1b[0m', "\n#####################################################################################\n ".concat(isDifference ? isDifferenceMessage : debugMessage, "\n ").concat(diffFilePath, "\n#####################################################################################\n"));
                    }
                    _e.label = 6;
                case 6: return [2, imageCompareOptions.returnAllCompareData
                        ? {
                            fileName: fileName,
                            folders: __assign({ actual: actualFilePath, baseline: baselineFilePath }, (diffFilePath ? { diff: diffFilePath } : {})),
                            misMatchPercentage: reportMisMatchPercentage,
                        }
                        : reportMisMatchPercentage];
            }
        });
    });
}
exports.executeImageCompare = executeImageCompare;
function makeFullPageBase64Image(screenshotsData, _a) {
    var devicePixelRatio = _a.devicePixelRatio, isLandscape = _a.isLandscape;
    return __awaiter(this, void 0, void 0, function () {
        var amountOfScreenshots, canvasHeight, canvasWidth, canvas, ctx, i, currentScreenshot, _b, screenshotHeight, screenshotWidth, isRotated, newBase64Image, _c, _d, canvasYPosition, imageHeight, imageWidth, imageXPosition, imageYPosition, image;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    amountOfScreenshots = screenshotsData.data.length;
                    canvasHeight = screenshotsData.fullPageHeight, canvasWidth = screenshotsData.fullPageWidth;
                    canvas = (0, canvas_1.createCanvas)(canvasWidth, canvasHeight);
                    ctx = canvas.getContext('2d');
                    i = 0;
                    _e.label = 1;
                case 1:
                    if (!(i < amountOfScreenshots)) return [3, 7];
                    currentScreenshot = screenshotsData.data[i].screenshot;
                    _b = (0, utils_1.getScreenshotSize)(currentScreenshot, devicePixelRatio), screenshotHeight = _b.height, screenshotWidth = _b.width;
                    isRotated = isLandscape && screenshotHeight > screenshotWidth;
                    if (!isRotated) return [3, 3];
                    return [4, rotateBase64Image({
                            base64Image: currentScreenshot,
                            degrees: -90,
                            newHeight: screenshotWidth,
                            newWidth: screenshotHeight,
                        })];
                case 2:
                    _c = _e.sent();
                    return [3, 4];
                case 3:
                    _c = currentScreenshot;
                    _e.label = 4;
                case 4:
                    newBase64Image = _c;
                    _d = screenshotsData.data[i], canvasYPosition = _d.canvasYPosition, imageHeight = _d.imageHeight, imageWidth = _d.imageWidth, imageXPosition = _d.imageXPosition, imageYPosition = _d.imageYPosition;
                    return [4, (0, canvas_1.loadImage)("data:image/png;base64,".concat(newBase64Image))];
                case 5:
                    image = _e.sent();
                    ctx.drawImage(image, imageXPosition, imageYPosition, imageWidth, imageHeight, 0, canvasYPosition, imageWidth, imageHeight);
                    _e.label = 6;
                case 6:
                    i++;
                    return [3, 1];
                case 7: return [2, canvas.toDataURL().replace(/^data:image\/png;base64,/, '')];
            }
        });
    });
}
exports.makeFullPageBase64Image = makeFullPageBase64Image;
function saveBase64Image(base64Image, filePath) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2, (0, fs_extra_1.outputFile)(filePath, base64Image, 'base64')];
        });
    });
}
exports.saveBase64Image = saveBase64Image;
function addBlockOuts(screenshot, ignoredBoxes) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, height, width, canvas, image, canvasContext;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = (0, utils_1.getScreenshotSize)(screenshot), height = _a.height, width = _a.width;
                    canvas = (0, canvas_1.createCanvas)(width, height);
                    return [4, (0, canvas_1.loadImage)("data:image/png;base64,".concat(screenshot))];
                case 1:
                    image = _b.sent();
                    canvasContext = canvas.getContext('2d');
                    canvasContext.drawImage(image, 0, 0, width, height, 0, 0, width, height);
                    ignoredBoxes.forEach(function (ignoredBox) {
                        var ignoredBoxWidth = ignoredBox.right, ignoredBoxHeight = ignoredBox.bottom, x = ignoredBox.left, y = ignoredBox.top;
                        var ignoreCanvas = (0, canvas_1.createCanvas)(ignoredBoxWidth - x, ignoredBoxHeight - y);
                        var ignoreContext = ignoreCanvas.getContext('2d');
                        ignoreContext.globalAlpha = 0.5;
                        ignoreContext.fillStyle = '#39aa56';
                        ignoreContext.fillRect(0, 0, ignoredBoxWidth - x, ignoredBoxHeight - y);
                        canvasContext.drawImage(ignoreCanvas, x, y);
                    });
                    return [2, canvas.toDataURL().replace(/^data:image\/png;base64,/, '')];
            }
        });
    });
}
exports.addBlockOuts = addBlockOuts;
function rotateBase64Image(_a) {
    var base64Image = _a.base64Image, degrees = _a.degrees, newHeight = _a.newHeight, newWidth = _a.newWidth;
    return __awaiter(this, void 0, void 0, function () {
        var canvas, ctx, image;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    canvas = (0, canvas_1.createCanvas)(newWidth, newHeight);
                    ctx = canvas.getContext('2d');
                    return [4, (0, canvas_1.loadImage)("data:image/png;base64,".concat(base64Image))];
                case 1:
                    image = _b.sent();
                    canvas.width = degrees % 180 === 0 ? image.width : image.height;
                    canvas.height = degrees % 180 === 0 ? image.height : image.width;
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate((degrees * Math.PI) / 180);
                    ctx.drawImage(image, image.width / -2, image.height / -2);
                    return [2, canvas.toDataURL().replace(/^data:image\/png;base64,/, '')];
            }
        });
    });
}
//# sourceMappingURL=images.js.map